import { Connection } from './Connection';
import { SessionInternal } from './SessionInternal';
import { OpenViduInternal, Callback } from './OpenViduInternal';
import EventEmitter = require('wolfy87-eventemitter');
export interface StreamOptionsServer {
    id: string;
    audioActive: boolean;
    videoActive: boolean;
    typeOfVideo: string;
}
export interface InboundStreamOptions {
    id: string;
    connection: Connection;
    recvAudio: boolean;
    recvVideo: boolean;
    typeOfVideo: string;
}
export interface OutboundStreamOptions {
    activeAudio: boolean;
    activeVideo: boolean;
    connection: Connection;
    dataChannel: boolean;
    mediaConstraints: any;
    sendAudio: boolean;
    sendVideo: boolean;
}
export declare class Stream {
    private openVidu;
    private local;
    private room;
    connection: Connection;
    streamId: string;
    hasVideo: boolean;
    hasAudio: boolean;
    typeOfVideo: string;
    ee: EventEmitter;
    private mediaStream;
    private wp;
    private video;
    private speechEvent;
    private showMyRemote;
    private localMirrored;
    private chanId;
    private dataChannelOpened;
    inboundOptions: InboundStreamOptions;
    outboundOptions: OutboundStreamOptions;
    private parentId;
    isReadyToPublish: boolean;
    isPublisherPublished: boolean;
    isVideoELementCreated: boolean;
    accessIsAllowed: boolean;
    accessIsDenied: boolean;
    isScreenRequestedReady: boolean;
    private isScreenRequested;
    constructor(openVidu: OpenViduInternal, local: boolean, room: SessionInternal, options: any);
    emitStreamReadyEvent(): void;
    removeVideo(parentElement: string): any;
    removeVideo(parentElement: Element): any;
    removeVideo(): any;
    getVideoElement(): HTMLVideoElement;
    setVideoElement(video: HTMLVideoElement): void;
    getParentId(): string;
    getRecvVideo(): boolean;
    getRecvAudio(): boolean;
    getSendVideo(): boolean;
    getSendAudio(): boolean;
    subscribeToMyRemote(): void;
    displayMyRemote(): boolean;
    mirrorLocalStream(wr: any): void;
    isLocalMirrored(): boolean;
    getChannelName(): string;
    isDataChannelEnabled(): boolean;
    isDataChannelOpened(): boolean;
    onDataChannelOpen(event: any): void;
    onDataChannelClosed(event: any): void;
    sendData(data: any): void;
    getMediaStream(): MediaStream;
    getWebRtcPeer(): any;
    addEventListener(eventName: string, listener: any): void;
    addOnceEventListener(eventName: string, listener: any): void;
    removeListener(eventName: any): void;
    showSpinner(spinnerParentId: string): void;
    hideSpinner(spinnerId?: string): void;
    playOnlyVideo(parentElement: any, thumbnailId: any): HTMLVideoElement;
    playThumbnail(thumbnailId: any): HTMLVideoElement;
    getParticipant(): Connection;
    getRTCPeerConnection(): any;
    requestCameraAccess(callback: Callback<Stream>): void;
    private requestCameraAccesAux(constraints, callback);
    private cameraAccessSuccess(userStream, callback);
    private userMediaHasVideo(callback);
    publishVideoCallback(error: any, sdpOfferParam: any, wp: any): void;
    startVideoCallback(error: any, sdpOfferParam: any, wp: any): void;
    private initWebRtcPeer(sdpOfferCallback);
    publish(): void;
    subscribe(): void;
    processSdpAnswer(sdpAnswer: any): void;
    unpublish(): void;
    dispose(): void;
    configureScreenOptions(options: OutboundStreamOptions): void;
}
